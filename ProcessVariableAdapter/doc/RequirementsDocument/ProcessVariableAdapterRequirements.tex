\documentclass[11pt,a4paper]{scrartcl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Default packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{textcomp}%\textmu 
\usepackage{graphicx}
\usepackage{subfig}%allow subfigures
\usepackage{amsmath}%improve layout of formulas
\usepackage{color}
\usepackage{units}%\unitfrac (nice m/s in text and math mode)
\usepackage{url}
\usepackage{booktabs}%\toprule, \midrule, bottomrule in tables
\usepackage{xspace}%automatically add space at the end of macros
\usepackage{upgreek}%\upright greek letters in math environment
\usepackage{authblk}%several authors with different affiliations
\usepackage{svn-multi}%svn revision in the tex file
\usepackage{threeparttable}% for footnotes within tables
\usepackage{multicol}%multimple columns

%% clickable links in pdf
\usepackage[pdftex,bookmarks=true,breaklinks=true,bookmarksnumbered=true,colorlinks=true,linkcolor=webgreen,citecolor=webred,urlcolor=webblue]{hyperref}
%% link colors
\definecolor{webred}{rgb}{0.5, 0, 0}
\definecolor{webgreen}{rgb}{0, 0.5, 0}
\definecolor{webblue}{rgb}{0, 0, 0.5}

%Command to allow footnotes within floats (tables, figures....)
%Use \floatingfootnotemark inside the float, which only places the mark and
%counts up the footnote counter.
%Immediately after the float you put the footnote text. We will see if it
%shows up on the right page....
\newcommand{\floatingfootnotemark}{\addtocounter{footnote}{1} \footnotemark[\value{footnote}]}
\newcommand{\floatingfootnotetext}[1]{\footnotetext[\value{footnote}]{#1}}

%A \fixme command with counter. At the end of the document you can display the counter to see how many FIXMEs are left
\newcounter{nFixmes}
\setcounter{nFixmes}{0}
\newcommand{\fixme}[1]{\addtocounter{nFixmes}{1}\textcolor{red}{(\includegraphics[height=2ex]{fixme} #1)}\xspace}

%file with the svn revision, generated using svnversion
\input{svnrevision.tex}

\title{Requirement for the MTCA4U Process Variable Adapter}
\date{\svnrevision\\ PDF build \today}
\author[1]{Martin Killenberg} \author[2]{Sebastian Marsching}
\author[3]{Adam Poitrokwsi}
\author[1]{Christian Schmidt}

\affil[1]{Deutsches Elektronen-Synchrotron DESY, Hamburg, Germany}
\affil[2]{aquenos GmbH, Baden-Baden, Germany}
\affil[3]{FastLogic Sp.\ z o.\ o., \L\'od\'z, Poland}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is where the document really begins
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\section{Objective and Scope}

MTCA4U's control system interface adapter is intended to decouple the business logic of a server from the actual control system in use. For this it provides two functionalities:
\begin{enumerate}
  \item Control System Variable adapters
  \item Function callbacks to react on control system interrupts
\end{enumerate}

\subsection{Control System Variable adapters}

The control system variable adapter is a thin layer which provides a standardised interface to access the variable content, but not to control system functionality. In other words, a control system variable that holds a signed 32 bit integer can be accessed as 32 bit integer from the business logic, but a variable history, which might be provided by the control system, is not accessible. The history is, however, accessible via the control system. Like this no control system functionality has to be abstracted or duplicated/implemented if not available on certain control systems.

The only exception is a list of callback functions which can be registered as actions to be taken when the variable is changed. This is needed to allow the synchronisation with the control system. The business logic can chose between a set()-function which only informs the control system, or a set()-function which also triggers the callbacks. When the variable is changed by the control system, the callbacks are always triggered. A more detailed explanation of the variable adapter can be found in the section~\ref{section_process_variable_adapter}.

\subsection{Control System Callback Function}

Control systems can trigger actions on signals, user interrupts or might implement events which represent an action which is not coupled to a process variable. The control system ad apter implements an interface so the business logic can define functions to be executed, and the control system dependent code implements how the particular function is triggered by the specific control system.

\subsection{Python interface}

For easy interactive testing it would be nice to have a python interface to the control system stub. Like this one can run tests of the full business logic without the necessity to install a control system. The interface might also be used to implement tests.

\section{Data Types}

\subsection{Simple Data Types}

The control system interface adapter supports ProcessVariable interface adapters for the following simple data types\\[2ex]
\begin{tabular}{rrrrr}
float & int8 & int16 & int32 & int64\\
double & uint8 & uint16 & uint32 & uint64 \\
string\\[2ex]
\end{tabular}

It is assumed that float, double, 16 bit integer and 32 bit integer are supported by all control systems \fixme{Check at least with DOOCS and EPICS}. In case the short integers are not supported, the next larger integer with range limitation is used. If no range limitations are available in the control system, the maximum allowed integer for the shorter type is set and reported back to the control system. In case 64 bit integers are not supported two 32 bit integers are used. \fixme{How to encode signed int64? Alternative solution: MTCA4U does not support 64 bit integers}
Control system specific data types are not supported.

\subsection{Strings}

Depending on the control system implementation the string might have limited length. If an input string is too long it will be truncated. The string has a “truncated” flag which can be queried. It intentionally does not throw an exception in order not to make servers crash which run fine on other control systems. In most cases there will be a truncated status message, which can be tolerated. There might be, however, malfunctions if the complete string is parsed automatically. In this case the parsing code will generate the error rather than the server terminating with an exception.

\subsection{Arrays}

MTCA4U supports arrays of all supported simple data types. \fixme{How to implement 64 bit integers if not supported by the CS?}

\section{Requirements for the ProcessVariable Adapter}\label{section_process_variable_adapter}

The ProcessVariable class holds an instance of the control system variable of the corresponding type. The control system usually implements a thread and locking scheme for the communication. This is the reason why ProcessVariables cannot be considered real time capable.

The business logic, however, will probably have a real time thread. For this reason it cannot be avoided to do one copy: From the lock-free variable used in the business logic into the control system variable. To avoid additional copying the ProcessVariable adapter does not contain an instance of the basic data type (or array), but accessors directly work with the control system variable. \fixme{Should it be recommended that the business logic always use a copy of the variable and not directly use adaptor? It might be that the variable changes during a calculation if used multiple time, and it might be slow because of frequent locking/unlocking.} 

The business logic has to create instances of process variables without knowing which particular implementation is needed. For this a factory pattern is used. Each variable is identified by a unique name, which is used to request creation of the variable from the factory. The actual address, under which the variable is seen from the control system, is control system specific and handled in the concrete factory. It is determined from the unique name.

The ProcessVariable adapter is not thread safe. If the underlying control system variables are thread safe, then the adapter is also thread safe as it does no further caching but direcly accesses the underlying variable. But this is not guaranteed by the interface and the user has to implement a thread safe mechanism himself. MTCA4U will provide thread support as a separate tool of the Control System Tools package. \fixme{I want to prevent reinventing the wheel. Should we just use the actor pattern implemented in boost::asio? MK}


\subsection{The ProcessVariable adapter interface features}
\begin{itemize}
\item a get() method
\item a set() method which triggers the callback functions
\item a list of callback functions which are executed if the variable contents changed
\item a set() method which does not trigger the callback functions. Like this it is possible the execute the callback functions only when the variable content is changed externally (from the control system), but update the variable from inside the business logic to inform the control system about the new value without triggering the callbacks.
  \fixme{Do we want a second list of callbacks for this?}
\item an assignment operator (for convenience, like set operator with callback) \fixme{without callback?} \fixme{This will probably only possible with an additional copy}
\item a const implicit conversion operator \fixme{Do we really need this? Business logic will use internal variables only. But how about simple, synchronous I/O servers?}
\end{itemize}

\subsection{Additional feature of the array interfaces}

\begin{itemize}
\item {[ ]} operator to access individual elements
\item iterators
\item size()
\end{itemize}

\subsection{Implementation details}

\begin{itemize}
\item Process variables are not copy-constructable as they have to be registered with a unique name. They have a private copy constructor.
\item The constructor is also private. Construction is done with a factory. The construction call takes a programme-wide unique name to identify the variable. With this the factory will be able to determine the required information to create the control system variable from a config file or data base.
N.B. Making the constructor private disables the possibility that the user writes control-system dependent code.
\fixme{This require the factory to be friend in order to access the constructor. Not so nice, but I don't see away around it which does not allow the user to write control system dependent code}
\item \fixme{Do we allow arrays to change size?}
\item Call back functions can be unregistered.
\item In case signed variables have to be implemented as unsigned in the control system, or vice versa, a reinterpret-cast is done in order not to lose information. In this case the negative range/ upper half of the dynamic range has to be reinterpreted by the user. An 'out of range' flag is set.
\item If only single precision floating point numbers are provided by the control system, the double is converted loosing precision. A 'limited precision' flag is set (statically in the concrete implementation.)
\end{itemize}

\subsection{Large data objects}

Some controls systems use synchronous operations like Remote Procedure Calls for data transmission. This is not efficient for large data objects or objects which have a very high update rate. In some cases (DOOCS for instance) the control system has a special mechanism for these data, other control systems like EPICS 3 usually require an 'out of band' implementation which adds a proprietary protocol. Some control systems, however, use asynchronous data protocols and can handle large data objects and high update rates efficiently (EPICS 4, Tango, Karabo, Tine(?) ).

As the decision if a special channel is needed and from which size depends on the control system, this has to be handled in the control system specific ProcessVariable factory. For the business logic and in the interface the notion of a special channel for high data rates does not exist.

\subsection{The ProcessVariable factory}

The factory allows the abstraction of the variable creation. Each user class which is programmed as a control system independent server is handed a reference or shared pointer of a concrete factory implementation. The factory is not implemented as a singleton pattern to allow the use of multiple factories simultaneously, for instance one for low bandwidth channels and one for high bandwidth channels (DAQ). This would allow to use the same 'out of band' factory for multiple control systems with slow, synchronous calls. For asynchronous control systems with sufficient bandwidth in the protocol the same factory would be handed to the server twice.

\section{Requirements for the Control System Function Callbacks}\label{section_function_callbacks}
\fixme{to be written}

\appendix
\section{DOOCS Variable Types}

Directly supported by the control system adapter in bold
\begin{multicols}{3}
\noindent D\_name \\
\textbf{D\_float}\\
D\_float\_ptr \\
\textbf{D\_floatarray}\\
\textbf{D\_double}\\
D\_double\_ptr \\
\textbf{D\_doublearray}\\
D\_gen\_sts \\
D\_sts \\
D\_status \\
D\_polynom \\
D\_hist \\
D\_histStat \\
D\_comment \\
\textbf{D\_string}\\
D\_zmqstring \\
D\_ustr \\
D\_text \\
D\_xml \\
D\_alarm \\
D\_devinfo \\
D\_plotinfo \\
D\_plotinfo\_p \\
D\_spectrum \\
D\_ifff \\
D\_filter \\
D\_dig\_filter \\
D\_bit \\
D\_xyzs \\
D\_iiii \\
\textbf{D\_int}\\
D\_int\_ptr \\
\textbf{D\_shortarray}\\
\textbf{D\_intarray}\\
\textbf{D\_longarray}\\
D\_call \\
D\_alarm \\
D\_exec \\
D\_error \\
D\_xy \\
D\_floatmean/D\_doublemean \\
D\_floatrms/D\_doublerms \\
D\_floatsigma/D\_doublesigma \\
D\_floatema/D\_doubleema \\
\textbf{D\_byte\_array}\\
D\_mdfloat\_array \\
D\_image \\
D\_imagec
\end{multicols}

Not supported by DOOCS:
\begin{itemize}
\item int8, int16 $\rightarrow$ use int32
\item int64 $\rightarrow$ \fixme{What to use?}
\item uint (all sizes) $\rightarrow$ use signed int with range check
\end{itemize}
The same for arrays.

\fixme{What is the difference between array and spectrum, except for some plotting meta information? How do we get a spectrum as currently used out of an array in the automated DOOCS dependent code (decide when to use array, when to use spectrum)?}

\section{EPICS Variable Types}
\fixme{Put list of EPICS variables here}

\section{FIXMEs}
Number of remaining FIXMEs: \arabic{nFixmes}

\end{document}
